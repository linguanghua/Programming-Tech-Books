算法

排序 ： 
		1、冒泡排序：平均复杂度 ：n方
		   双重循环，一个标志位。
		   标志位用于判断里面一层循环是否进行了元素位置交换。
		   里面一层循环，从左到右不断交换相邻逆序的元素，最大的元素浮动到右侧。
		   外侧循环，保证进行多次里层循环，因为里层循环一层只能排序一个元素

		   冒泡排序：在一次循环中，元素位置交换可能会发生很多次

		2、选择排序： 平均复杂度 ：n方
           双重循环，里层循环找到最小元素，循环结束之后，把最小的元素换到有序列表的末尾

           需要一个变量记录当次循环的最小元素的位置
           一个变量记录下一个有序元素交换的位置

           选择排序： 在里层循环结束之后，进行一次交换操作

		3、插入排序  平均复杂度：n方
           双重循环，从第2个元素开始。
           每次操作，将当前元素与前面的元素进行比较，如果前一个元素比当前元素大，那么将前面的元素往后移，
           移出一个空位，将当前元素插入

           插入排序：每次操作的是，将前面的元素往后移动，移出一个空位置

		4、希尔排序 平均复杂度：nlogn
           插入排序的改进版
           插入排序是将当前元素从后往前跟前面的元素比较，移出一个合适的插入位置。
           希尔排序是从前往后跟一定跨度（一般选len/2的值）的比较
           三层循环


		5、归并排序 平均时间复杂度 nlogn
		
			归并排序 使用分治法
            先将大数组分成小数组，然后有序的子数组在合并

            自顶向下排序
                将大数组分成小数组
			自底向上排序
			    先归并微小数组，然后归并得到的次大数组，最终的到大数组

		6、快速排序
		   双指针
		   将数组最后一个元素作为基准值，将基准值保存下来。
		     循环开始
		       左指针先走，一直找到大于基准值的数。找到之后，将这个数与右指针的数交换。
		       右指针开始走，找到小于基准的值，找到之后，跟左指针的数交换
		       下一次循环

		     退出循环：
		     将左指针的值设置成之前保存的值，返回左指针




		7、快速选择排序
		8、堆排序

			一种树形选择排序
			堆：一种完全二叉树，满足父节点的值大于等于（小于等于）字节点的值


		9、桶排序
		10、计数排序
		11、基数排序

链表 ：
        1、反转链表
        2、删除倒数第k个链表
        3、合并两个有序链表





思想 ：
	1、双指针
	2、动态规划	   最大公共子串
	3、斐波那契     青蛙跳台阶
    4、二分查找















    归并排序代码（）：


    public int[] merge(int[] nums,int l, int m, int h){

    	int i = l, j = m+1;

    	int[] temp = Arrays.copy(nums)

    	for(int k = l;k<=h;k++){
    	    if(i>m){
    	       temp[k] = nums[j++];
    	    }else(j>h){
    	    	temp[k] = nums[i++];
    	    }else if(temp[i]<=temp[j]){
    	        nums[k] = temp[i++];
    	    }else{
    	        nums[k] = temp[j++];
    	    }


    	}

    }


    快速排序

    双指针：

    private int pattition(int[] arr,int left,int right){
    	int key = arr[right];
    	while(left<right){
    		while(left<right && arr[left]<=key){
    			left++
    		}
    		arr[right] = arr[left];

    		while(left<right && arr[right]>=key){
    			right--;
    		}
    		arr[left] = arr[right];
    	}
    	arr[left] = key;
    	return left;
    }

    private void QuickSort(int[] arr,int left,int right){
    	if(left<right){
    		int pos = pattition(arr,left,right);
    		QuickSort(arr,left,pos-1);
    		QuickSort(arr,pos+1,right);
    	}
    }



    // leetcode 第3题

    求一个字符串的公共子串

    1、将字符串转换成字符数组
    2、定义3个索引指针，一个用于从头到尾遍历字符数组，一个用于记录最大子串的第一个字符，一个用于记录当前子串的第一个字符
    3、定义3个int变量，一个记录当前最大子串的长度，一个记录当前子串的长度，一个用于记录重复字符上一次出现的位置


3. 无重复字符的最长子串

30. 串联所有单词的子串

76. 最小覆盖子串

159. 至多包含两个不同字符的最长子串

209. 长度最小的子数组

239. 滑动窗口最大值

567. 字符串的排列

632. 最小区间

727. 最小窗口子序列 



